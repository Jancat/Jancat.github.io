<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>键落云起</title>
    <link>https://jancat.github.io/</link>
    <description>Recent content on 键落云起</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Sat, 21 Apr 2018 10:59:40 +0800</lastBuildDate>
    
        <atom:link href="https://jancat.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Win10 VMware 安装 Elementary OS</title>
      <link>https://jancat.github.io/post/2018/win10-vmware-install-elementary-os/</link>
      <pubDate>Sat, 21 Apr 2018 10:59:40 +0800</pubDate>
      
      <guid>https://jancat.github.io/post/2018/win10-vmware-install-elementary-os/</guid>
      
        <description>&lt;p&gt;&lt;img src=&#34;https://jancat.github.io/images/post/win10-vmware-install-elementary-os/elementary-os-poster.jpg&#34; alt=&#34;Elementary OS Poster&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;elementary OS是一个基于Ubuntu的Linux发行版。它使用一个自己开发的基于GNOME的名为Pantheon的桌面环境。 这个桌面环境出众的原因是它深度集成了其他elementary OS应用程序，如Plank（一个基于Docky的Dock）、Midori（默认的网页浏览器）或Scratch（一个简单的文本编辑器）。该发行版使用基于Mutter的Gala作为其窗口管理器。&lt;/p&gt;

&lt;p&gt;这个发行版是从为Ubuntu设计的一套主题和应用程序发展而来的。由于是基于Ubuntu的，因此与Ubuntu的仓库和包完全兼容。它使用Ubuntu自己的软件中心来处理软件的安装和卸载。其类似于Mac OS X的界面致力于使新用户不需要费太大力气就可以根据直觉使用。
—— &lt;a href=&#34;https://zh.wikipedia.org/wiki/Elementary_OS&#34;&gt;elementary OS wiki&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;2018年，&lt;strong&gt;elementary OS&lt;/strong&gt; 有文章评价为“&lt;strong&gt;最美的Linux桌面发行版&lt;/strong&gt;”，其桌面环境和使用跟 Mac OS X 很相似；如果你想在 Windows 下拥有 Mac 系统的操作体验，那么在虚拟机中安装 elementary os 是个最好的选择，可以随时在 Windows 办公娱乐、elementary OS 开发环境之间切换。&lt;/p&gt;

&lt;p&gt;本文将一步步介绍在 Win10 VMware 中安装 elementary OS 的步骤。&lt;/p&gt;

&lt;h3 id=&#34;下载-elementary-os-镜像&#34;&gt;下载 Elementary OS 镜像&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;进入官网 &lt;a href=&#34;https://elementary.io/zh_CN/&#34;&gt;https://elementary.io/zh_CN/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;输入金额 0，点击下载 iso 镜像
&lt;img src=&#34;https://jancat.github.io/images/post/win10-vmware-install-elementary-os/download-elementary-os-iso.png&#34; alt=&#34;download-elementary-os-iso&#34; /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;下载安装-vmware-workstation-pro&#34;&gt;下载安装 VMware Workstation Pro&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;进入 VMware 官网下载页面下载 &lt;a href=&#34;https://my.vmware.com/en/web/vmware/info/slug/desktop_end_user_computing/vmware_workstation_pro/14_0&#34;&gt;https://my.vmware.com/en/web/vmware/info/slug/desktop_end_user_computing/vmware_workstation_pro/14_0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;安装&lt;/li&gt;
&lt;li&gt;输入序列号激活 &lt;code&gt;CV7T2-6WY5Q-48EWP-ZXY7X-QGUWD&lt;/code&gt;、&lt;code&gt;FF31K-AHZD1-H8ETZ-8WWEZ-WUUVA&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;创建-elementary-os-虚拟机&#34;&gt;创建 elementary OS 虚拟机&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;启动 VMware&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;创建新的虚拟机，选择&lt;strong&gt;自定义&lt;/strong&gt;，下一步
&lt;center&gt;
&lt;img src=&#34;https://jancat.github.io/images/post/win10-vmware-install-elementary-os/new-vm.png&#34; alt=&#34;new-vm&#34; /&gt;
&lt;/center&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;选择虚拟机兼容性，默认下一步&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;选择&lt;strong&gt;安装程序光盘映像文件&lt;/strong&gt;，选中刚才下载的 Elementary OS iso镜像文件，下一步
&lt;center&gt;
&lt;img src=&#34;https://jancat.github.io/images/post/win10-vmware-install-elementary-os/select-iso.png&#34; alt=&#34;select-iso&#34; /&gt;
&lt;/center&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;操作系统版本选择 &lt;strong&gt;Linux&lt;/strong&gt;、&lt;strong&gt;其他 Linux 4.x 或更高版本内核 64位&lt;/strong&gt;，下一步
&lt;center&gt;
&lt;img src=&#34;https://jancat.github.io/images/post/win10-vmware-install-elementary-os/select-os.png&#34; alt=&#34;select-os&#34; /&gt;
&lt;/center&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;修改默认的虚拟机名称和存储位置，下一步
&lt;center&gt;
&lt;img src=&#34;https://jancat.github.io/images/post/win10-vmware-install-elementary-os/vm-location.png&#34; alt=&#34;vm-location&#34; /&gt;
&lt;/center&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;处理器配置2核（当前操作系统内核数的一半），下一步
&lt;center&gt;
&lt;img src=&#34;https://jancat.github.io/images/post/win10-vmware-install-elementary-os/vm-cpu.png&#34; alt=&#34;vm-cpu&#34; /&gt;
&lt;/center&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;内存看个人选择，这里选择3G，下一步
&lt;center&gt;
&lt;img src=&#34;https://jancat.github.io/images/post/win10-vmware-install-elementary-os/vm-memory.png&#34; alt=&#34;vm-memory&#34; /&gt;
&lt;/center&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;网络类型选择 &lt;strong&gt;桥接网络&lt;/strong&gt;，下一步
&lt;center&gt;
&lt;img src=&#34;https://jancat.github.io/images/post/win10-vmware-install-elementary-os/vm-network.png&#34; alt=&#34;vm-network&#34; /&gt;
&lt;/center&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;选择I/O控制器类型，默认下一步&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;选择硬盘类型，默认下一步&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;创建新虚拟磁盘，（使用物理磁盘可能会影响到主机系统的正常使用），下一步
&lt;center&gt;
&lt;img src=&#34;https://jancat.github.io/images/post/win10-vmware-install-elementary-os/vm-disk.png&#34; alt=&#34;vm-disk&#34; /&gt;
&lt;/center&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;最大磁盘大小根据个人选择，这里选择40G，选择&lt;strong&gt;将虚拟磁盘存储为单个文件&lt;/strong&gt;，下一步
&lt;center&gt;
&lt;img src=&#34;https://jancat.github.io/images/post/win10-vmware-install-elementary-os/vm-disk-size.png&#34; alt=&#34;vm-disk-size&#34; /&gt;
&lt;/center&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;完成创建虚拟机
&lt;center&gt;
&lt;img src=&#34;https://jancat.github.io/images/post/win10-vmware-install-elementary-os/vm-done.png&#34; alt=&#34;vm-done&#34; /&gt;
&lt;/center&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;安装-elementary-os&#34;&gt;安装 elementary OS&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;开启此虚拟机&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;语言选择 &lt;strong&gt;English&lt;/strong&gt;（或者中文简体），点击&lt;strong&gt;Install Elementary&lt;/strong&gt;
&lt;center&gt;
&lt;img src=&#34;https://jancat.github.io/images/post/win10-vmware-install-elementary-os/os-language.png&#34; alt=&#34;os-language&#34; /&gt;
&lt;/center&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;选择 &lt;strong&gt;Install third-party software&lt;/strong&gt;，continue
&lt;center&gt;
&lt;img src=&#34;https://jancat.github.io/images/post/win10-vmware-install-elementary-os/os-install-third-party-software.png&#34; alt=&#34;os-install-third-party-software&#34; /&gt;
&lt;/center&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Install Type 默认选择&lt;strong&gt;擦除磁盘安装Elementary OS&lt;/strong&gt;，点击&lt;strong&gt;Install Now&lt;/strong&gt;，&lt;strong&gt;Continue&lt;/strong&gt;
&lt;center&gt;
&lt;img src=&#34;https://jancat.github.io/images/post/win10-vmware-install-elementary-os/os-install-type.png&#34; alt=&#34;os-install-type&#34; /&gt;
&lt;/center&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;选择城市，&lt;strong&gt;Contiune&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;键盘布局选择&lt;strong&gt;Chiese&lt;/strong&gt;，&lt;strong&gt;Continue&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;设置个人用户名、密码&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;安装过程等待5分钟左右，完成后重启
&lt;center&gt;
&lt;img src=&#34;https://jancat.github.io/images/post/win10-vmware-install-elementary-os/os-done.jpg&#34; alt=&#34;os-done&#34; /&gt;
&lt;/center&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;在虚拟机中安装-vmtools&#34;&gt;在虚拟机中安装 VMTools&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;选择 &lt;strong&gt;虚拟机 &amp;gt; 安装 VMware Tools&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在虚拟机中会挂载 &lt;strong&gt;VMware Tools&lt;/strong&gt; CD&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;进入挂载的 &lt;strong&gt;VMware Tools&lt;/strong&gt;，拷贝&lt;strong&gt;VMwareTools&lt;/strong&gt;文件到&lt;strong&gt;Documents&lt;/strong&gt;目录下（在CDROM中无法写入）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;进入&lt;strong&gt;Documents&lt;/strong&gt;目录，用&lt;code&gt;tar&lt;/code&gt;命令解压&lt;strong&gt;VMwareTools&lt;/strong&gt;文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;tar zxf VMwareTools
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;进入解压出的&lt;strong&gt;VMwareTools&lt;/strong&gt;，执行&lt;strong&gt;vmware-install.pl&lt;/strong&gt;文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;cd VMwareTools
sudo vmware-install.pl
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;一路默认回车，完成安装&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;要在主机和虚拟机之间拖拽文件和复制粘贴文本，需要执行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;/usr/bin/vmware-user
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;注销，重新登录&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;虚拟机无法连接网络&#34;&gt;虚拟机无法连接网络&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;虚拟机 &amp;gt; 设置 &amp;gt; 选择桥接模式
&lt;center&gt;
&lt;img src=&#34;https://jancat.github.io/images/post/win10-vmware-install-elementary-os/network-bridge.png&#34; alt=&#34;network-bridge&#34; /&gt;
&lt;/center&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;编辑 &amp;gt; 虚拟网络编辑器 &amp;gt; 桥接模式桥接到你的物理网卡
&lt;center&gt;
&lt;img src=&#34;https://jancat.github.io/images/post/win10-vmware-install-elementary-os/network-edit.png&#34; alt=&#34;network-edit&#34; /&gt;
&lt;/center&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;测试主机和虚拟机之间能够互相访问&#34;&gt;测试主机和虚拟机之间能够互相访问&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;主机ping虚拟机IP&lt;/li&gt;
&lt;li&gt;虚拟机访问主机开启的http服务（可能无法ping通主机IP）&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;到这里，elementary OS 在 VMware 中就安装完成了，后面还会介绍 elementary OS 的初始化和使用&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>如何选择技术博客的发布方式</title>
      <link>https://jancat.github.io/post/2018/how-to-select-the-way-to-post-teach-blog/</link>
      <pubDate>Fri, 20 Apr 2018 21:41:23 +0800</pubDate>
      
      <guid>https://jancat.github.io/post/2018/how-to-select-the-way-to-post-teach-blog/</guid>
      
        <description>&lt;p&gt;之前一直有记录笔记的习惯，但都是不公开只给自己看的“笔记”，不能见人那种，怎么简单怎么来，方便下次快速索引；这样的内容肯定缺乏正常文章要有的完整性、可读性、逻辑连贯性。。。&lt;/p&gt;

&lt;p&gt;为了锻炼自己的文字表达能力，和本着知识分享的精神，顺带系统整理下曾经的个人笔记，于是开始写公开的博客文章，在搜索引擎中留下自己的印记。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h4 id=&#34;文章发布网站的选择&#34;&gt;文章发布网站的选择&lt;/h4&gt;

&lt;p&gt;技术文章如果要发布在公共的网站上，现在一般有几种选择：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;简书
比较受欢迎的Markdown文章创作社区，各种类型的文章都有，但就是因为太泛了，技术氛围不够，专业性不强。但对于普通的不爱折腾的作者来说已经足够了，可以更加专注在文章创作上。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;segmentfault
segmentfault 专栏也是发布技术文章比较好的选择，网站体验也很不错，相信会越来越流行。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;知乎
&amp;gt; 程序员小隐隐于野，中隐隐于楼，大隐隐知乎&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;很多程序员经常出没于知乎，技术文章也很自然地会发在上面。但也是跟简书一样的情况，夹杂在这么多非技术文章/问答中，总是感觉不够专业，比简书更甚。&lt;/p&gt;

&lt;p&gt;如果上面几种方式都不能满足你，那或许你是个比较喜欢折腾的人，想要与众不同，尝试自己建博客网站，建立独特的个人标识。&lt;/p&gt;

&lt;h4 id=&#34;从零写起-or-使用静态网站生成器&#34;&gt;从零写起 or 使用静态网站生成器？&lt;/h4&gt;

&lt;p&gt;自建博客网站也是一条坦坦大道，很多程序员都喜欢有自己专属的网站，声明自己的独特性。个人网站几乎成了Geek的标配，如果没有反而会有点奇怪。&lt;/p&gt;

&lt;p&gt;个人博客虽然不是复杂的网站，但是要自己从零写出来达到能满足正常使用的程度，还是要花大量时间精力在上面的。虽然这样能凸显自己的能力，个性化程度高，但如果不是执着于“&lt;strong&gt;DIY&lt;/strong&gt;”，这里还是不推荐这种方式的。&lt;/p&gt;

&lt;p&gt;那最后就剩下 &lt;strong&gt;静态网站生成器(SSG, Static Site Generator)&lt;/strong&gt; 这个选择了，关于 &lt;strong&gt;SSG&lt;/strong&gt; ，可以阅读这个博客的前半部分 &lt;a href=&#34;https://www.jianshu.com/p/c50dab7a98ef&#34;&gt;利用静态网站生成器制作静态博客网站&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;简单来说，&lt;strong&gt;SSG&lt;/strong&gt; 就是帮我们自动生成静态网站的工具，很多开源的网站主题可以选择，也可以自己制作主题自用和共享。一般只要改下配置文件和创建markdown文章就能部署了。&lt;/p&gt;

&lt;h4 id=&#34;静态网站生成器的选择&#34;&gt;静态网站生成器的选择&lt;/h4&gt;

&lt;p&gt;静态网站生成器 现在有上百个，原理和使用方式都大同小异，但在不了解的情况下选择出最合适自己的还是比较纠结的。幸好有个专门统计 &lt;strong&gt;SSG&lt;/strong&gt; 的网站 &lt;a href=&#34;https://www.staticgen.com/&#34;&gt;Staitc Gen&lt;/a&gt;，里面展示了几乎所有开源的 &lt;strong&gt;SSG&lt;/strong&gt;，根据Github Project的数据（默认是Stars数）来进行排列。&lt;/p&gt;

&lt;p&gt;这里就从主要的三个 &lt;strong&gt;SSG&lt;/strong&gt; 来选择：&lt;strong&gt;Jekyll&lt;/strong&gt;、&lt;strong&gt;Hugo&lt;/strong&gt;、&lt;strong&gt;Hexo&lt;/strong&gt;&lt;/p&gt;

&lt;h4 id=&#34;jekyll&#34;&gt;Jekyll&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;https://jekyllrb.com/&#34;&gt;Jekyll&lt;/a&gt; 是比较早期的项目了，从2008年开始，目前Github Stars数量排行第一；使用 &lt;strong&gt;Ruby&lt;/strong&gt; 语言实现，是 &lt;strong&gt;Github Pages&lt;/strong&gt; 推荐的 SSG。&lt;/p&gt;

&lt;p&gt;默认情况下，优先选择最流行的是没错的，所以首先拿 &lt;code&gt;Jekyll&lt;/code&gt; 在 &lt;strong&gt;Win10&lt;/strong&gt; 上试试水。&lt;/p&gt;

&lt;p&gt;按照官网的安装步骤走，在 &lt;code&gt;Win10&lt;/code&gt; 上准备环境还是比较&lt;strong&gt;艰难&lt;/strong&gt;的，光 &lt;strong&gt;Ruby&lt;/strong&gt; 环境的安装都很&lt;strong&gt;折腾&lt;/strong&gt;，即使按照官网推荐的方式使用&lt;strong&gt;WSL&lt;/strong&gt;(Window Subsystem Linux)，&lt;strong&gt;在Win10上安装Ubuntu&lt;/strong&gt; 终端环境，最后还是出现很多问题没解决，还没走到 &lt;strong&gt;Jekyll&lt;/strong&gt; 那一步就被坑在洞里爬不出来，遂放弃。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;不建议在Win10系统上安装Jekyll&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;在&lt;strong&gt;Mac&lt;/strong&gt;上安装应该比较容易，但这里只讨论&lt;strong&gt;Windows&lt;/strong&gt;系统环境，Mac党可以尝试一下。&lt;/p&gt;

&lt;h4 id=&#34;hexo&#34;&gt;Hexo&lt;/h4&gt;

&lt;p&gt;&lt;a href=&#34;https://hexo.io/&#34;&gt;Hexo&lt;/a&gt; 是2012年的项目，发展到现在，也是目前使用的比较多的SSG。Github Stars数量排第四，使用 &lt;strong&gt;Node.js&lt;/strong&gt; 实现。&lt;/p&gt;

&lt;p&gt;如果不是后面新崛起的 &lt;strong&gt;Hugo&lt;/strong&gt;，或许就被我选中了，可惜没有如果。&lt;/p&gt;

&lt;h4 id=&#34;hugo&#34;&gt;Hugo&lt;/h4&gt;

&lt;blockquote&gt;
&lt;p&gt;本文压轴终于出场了🎉&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;http://gohugo.io/&#34;&gt;Hugo&lt;/a&gt; 使用 &lt;strong&gt;Go&lt;/strong&gt; 语言实现，目前Github Stars数量排第二，仅次于老牌 Jekyll。崛起于2017年，在2018年作为新兴SSG迅速流行起来，本站也是使用 Hugo 建站。官网上号称“&lt;strong&gt;世界上建站最快的框架&lt;/strong&gt;”（官网你皮这一下开心吗？）&lt;/p&gt;

&lt;p&gt;hugo.io 域名被抢注了，官网用 gohugo.io 虽是无奈之举，但也挺机智。&lt;/p&gt;

&lt;p&gt;Win10 轻松安装 Hugo ➡ &lt;code&gt;choco install hugo&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Hugo 模板语法不太适应，如果需要自己创建主题或者自定义已有的主题，还是先要在官网了解一堆概念的。&lt;/p&gt;

&lt;p&gt;希望有一天能够出自己的主题🙃&lt;/p&gt;

&lt;h4 id=&#34;最后&#34;&gt;最后&lt;/h4&gt;

&lt;p&gt;以上只是我个人的经验见解，仅供参考，怎样选择还是要靠&lt;strong&gt;眼缘&lt;/strong&gt;和&lt;strong&gt;眼力&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;（如果还是纠结，那就 &lt;strong&gt;Hugo&lt;/strong&gt; 吧）&lt;/p&gt;</description>
      
    </item>
    
    <item>
      <title>关于</title>
      <link>https://jancat.github.io/about/</link>
      <pubDate>Fri, 20 Apr 2018 09:10:24 +0000</pubDate>
      
      <guid>https://jancat.github.io/about/</guid>
      
        <description>&lt;p&gt;&lt;img src=&#34;https://jancat.github.io/images/post/about/about-background.jpg&#34; alt=&#34;background&#34; /&gt;&lt;/p&gt;

&lt;p&gt;游走于文艺边缘，心中常住着持剑的少年&lt;/p&gt;

&lt;p&gt;向往二次元，正因无法企及&lt;/p&gt;

&lt;p&gt;喜欢Coding带来的成就感&lt;/p&gt;
</description>
      
    </item>
    
    <item>
      <title>使用Node和Typescript爬取花瓣网图片</title>
      <link>https://jancat.github.io/post/2018/huaban-crawler-with-node-and-typescript/</link>
      <pubDate>Thu, 19 Apr 2018 04:03:44 +0000</pubDate>
      
      <guid>https://jancat.github.io/post/2018/huaban-crawler-with-node-and-typescript/</guid>
      
        <description>&lt;p&gt;&lt;img src=&#34;https://jancat.github.io/images/post/huaban-crawler-with-node-and-typescript/huban-logo.jpg&#34; alt=&#34;huban-logo&#34; /&gt;
&lt;/p&gt;

&lt;!-- @import &#34;[TOC]&#34; {cmd=&#34;toc&#34; depthFrom=1 depthTo=6 orderedList=false} --&gt;

&lt;!-- code_chunk_output --&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#前言&#34;&gt;前言&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#技术选型&#34;&gt;技术选型&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#花瓣网技术分析&#34;&gt;花瓣网技术分析&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#画板资源&#34;&gt;画板资源&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#board-data&#34;&gt;Board Data&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#图片懒加载&#34;&gt;图片懒加载&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#node-爬虫实现&#34;&gt;Node 爬虫实现&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#输入画板id下载该画板的所有图片&#34;&gt;输入画板ID下载该画板的所有图片&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#输入用户id下载该用户所有自建画板的图片不包括收藏的画板&#34;&gt;输入用户ID下载该用户所有自建画板的图片（不包括收藏的画板）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#总结&#34;&gt;总结&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#github-project&#34;&gt;Github Project&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;!-- /code_chunk_output --&gt;

&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://huaban.com&#34;&gt;花瓣网&lt;/a&gt; 最初是模仿国外的 &lt;a href=&#34;https://www.pinterest.com/&#34;&gt;Pinterest&lt;/a&gt; 开始做起来的图片采集分享网站，国内类似的网站有&lt;a href=&#34;https://www.duitang.com/&#34;&gt;堆糖&lt;/a&gt;。在初期的用户积累阶段过后，花瓣网近几年开始探索其商业模式，以“图”为中心向相关领域延伸（摄影、设计、Live、电商导购等），不过不管怎么发展，用户体验还是要放在首位的，不忘初衷。&lt;/p&gt;

&lt;p&gt;作为国内优秀的图片网站,其流畅的瀑布流图片展示、简单易用的图片采集分类方式、强大的图片采集插件，让我这个图控坚持在这里深耕多年，采集了几万张图片，骗粉几千个（欢迎关注 &lt;a href=&#34;http://huaban.com/junlin/&#34;&gt;http://huaban.com/junlin/&lt;/a&gt; ）。&lt;/p&gt;

&lt;p&gt;然而对于&lt;strong&gt;图控+收藏控&lt;/strong&gt;来说，花瓣网也只是&lt;strong&gt;个人图库大计&lt;/strong&gt;中的其中一环，毕竟还是有很多&lt;del&gt;私图&lt;/del&gt;不宜光明正大放出来的，花瓣网也有违规图片检测机制，所以需要汇总花瓣网采集的图片到个人存储库中（网盘or硬盘）；此为&lt;u&gt;纯纯的&lt;/u&gt;动机，也是本文出现的原因。&lt;/p&gt;

&lt;h3 id=&#34;技术选型&#34;&gt;技术选型&lt;/h3&gt;

&lt;p&gt;这么多图片手工一个个下载肯定是不现实的，花瓣网也没有提供批量下载画板的功能（要是有就省心了，可能是考虑到这功能开放后会影响网站运营），这样就催生了很多批量下载工具、脚本（&lt;a href=&#34;https://www.douban.com/group/473118/&#34;&gt;豆皮DouP相册下载器豆瓣小组&lt;/a&gt;、Github 爬虫项目），基本都能很方便的下载。&lt;/p&gt;

&lt;p&gt;本着一颗不安分喜欢折腾的心，也是出于技术学习目的，打算自己实现一个批量下载的爬虫脚本。虽然爬虫首选Python，但，作为相信着 &lt;strong&gt;Atwood定律&lt;/strong&gt; 的前端er，&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;any application that can be written in JavaScript, will eventually be written in JavaScript.
（任何能够用JavaScript实现的应用，最终都必将由JavaScript实现。）
&amp;ndash; Jeff Atwood&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;很自然的选择了 &lt;strong&gt;Node.js&lt;/strong&gt; ，再加上越来越来流行的 &lt;strong&gt;TypeScript&lt;/strong&gt;，如虎添翼，Perfect！&lt;/p&gt;

&lt;h2 id=&#34;花瓣网技术分析&#34;&gt;花瓣网技术分析&lt;/h2&gt;

&lt;p&gt;首先打开花瓣网任意一个&lt;strong&gt;画板&lt;/strong&gt;，在 Chrome DevTools - Network 下观察它和服务器之前的交互。&lt;/p&gt;

&lt;h3 id=&#34;画板资源&#34;&gt;画板资源&lt;/h3&gt;

&lt;p&gt;刷新后发现有很多网络请求，注意到最开始有个带有&lt;strong&gt;画板ID&lt;/strong&gt;的 Request &lt;a href=&#34;http://huaban.com/boards/17473820/&#34;&gt;http://huaban.com/boards/17473820/&lt;/a&gt; ，应该就是它了，服务器响应的是一个 HTML Document。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://jancat.github.io/images/post/huaban-crawler-with-node-and-typescript/board-request.png&#34; alt=&#34;board-request&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;board-data&#34;&gt;Board Data&lt;/h3&gt;

&lt;p&gt;在这个 HTML Document 中发现有个 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 中带有大量的 &lt;strong&gt;board&lt;/strong&gt; 数据：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;app.page[&#39;board&#39;] = {
  board_id: 17473820,
  user_id: 14191742,
  title: &#39;◈ 二次元 少女 ◈&#39;,
  description: &#39;三次元之外的一片净土，满满的治愈~&#39;,
  category_id: &#39;anime&#39;,
  seq: 3,
  pin_count: 12627,
  follow_count: 1004,
  like_count: 37,
  created_at: 1410342416,
  updated_at: 1523766920,
  deleting: 0,
  is_private: 0,
  extra: { cover: { pin_id: &#39;407033830&#39; } },
  user: { ... },
  category_name: &#39;动漫&#39;,
  following: false,
  liked: false,
  pins: [
    {
      pin_id: 1595477246,
      user_id: 14191742,
      board_id: 17473820,
      file_id: 183940093,
      file: {
        id: 183940093,
        farm: &#39;farm1&#39;,
        bucket: &#39;hbimg&#39;,
        key: &#39;95b6f7594128756a5fb415188cb5761c4139cebbf359b-R9Dvyn&#39;,
        type: &#39;image/jpeg&#39;,
        width: 752,
        height: 1062,
        frames: 1,
        colors: [{ color: 5934, ratio: 0.09 }],
        theme: &#39;00172e&#39;,
      },
      media_type: 0,
      source: &#39;pixiv.net&#39;,
      link: &#39;https://www.pixiv.net/member_illust.php?mode=medium&amp;amp;illust_id=67752097&#39;,
      raw_text: &#39;奏さん&#39;,
      text_meta: { tags: [] },
      via: 1587727234,
      via_user_id: 8451317,
      original: 1568136527,
      created_at: 1523444564,
      like_count: 1,
      comment_count: 0,
      repin_count: 3,
      is_private: 0,
      extra: null,
      orig_source: null,
      tags: [],
    },
    { ... },
    ...
  ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中 &lt;code&gt;app.page.board.pins&lt;/code&gt; 是一个对象数组，里面每个对象对应着画板中其中一张图片的信息，&lt;code&gt;pin&lt;/code&gt; 代表一张图片的信息。&lt;/p&gt;

&lt;p&gt;在网页中检查第一张图片的源 &lt;code&gt;&amp;lt;img src=&amp;quot;//img.hb.aicdn.com/95b6f7594128756a5fb415188cb5761c4139cebbf359b-R9Dvyn_fw236&amp;quot;&amp;gt;&lt;/code&gt;，可以发现花瓣网图片使用了又拍云的CDN服务，第二部分即是上面的 &lt;code&gt;pins[0].file.key&lt;/code&gt; 加上一个 &lt;code&gt;_fw236&lt;/code&gt; 后缀；其它图片的 &lt;code&gt;src&lt;/code&gt; 都带有这个 &lt;code&gt;_fw236&lt;/code&gt; 后缀，暂时还不知道它的意义。&lt;/p&gt;

&lt;p&gt;拿到了画板图片信息，到这一步就能想到可以通过爬虫来下载画板的图片。&lt;/p&gt;

&lt;h3 id=&#34;图片懒加载&#34;&gt;图片懒加载&lt;/h3&gt;

&lt;p&gt;再回到画板网页上，看到页面上目前只加载了画板一部分图片，剩下的图片是通过&lt;strong&gt;懒加载&lt;/strong&gt;的方式出现的（想想就知道不能一次性把所有图片都加载出来）。&lt;/p&gt;

&lt;p&gt;拖动滚动条到底部，继续观察 &lt;strong&gt;Network&lt;/strong&gt;，第一个请求 &lt;a href=&#34;http://huaban.com/boards/17473820/?jg6ltavl&amp;amp;max=1584529804&amp;amp;limit=20&amp;amp;wfl=1&#34;&gt;http://huaban.com/boards/17473820/?jg6ltavl&amp;amp;max=1584529804&amp;amp;limit=20&amp;amp;wfl=1&lt;/a&gt; 在画板ID后面携带了一些参数：&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://jancat.github.io/images/post/huaban-crawler-with-node-and-typescript/board-lazy-load.png&#34; alt=&#34;board-lazy-load&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;jg6ltavl: 
max: 1584529804
limit: 20
wfl: 1
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;第一个参数是个随机字符串，最后一位按字母表顺序循环，没发现有什么意义，忽略；&lt;/li&gt;
&lt;li&gt;第二个参数 &lt;strong&gt;max&lt;/strong&gt; 的值是个 &lt;strong&gt;pin_id&lt;/strong&gt; ；&lt;/li&gt;
&lt;li&gt;第三个参数 &lt;strong&gt;limit&lt;/strong&gt; 限制了服务器返回的 &lt;strong&gt;pin 数量&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;第四个参数 &lt;strong&gt;wfl&lt;/strong&gt; 可能是 &lt;strong&gt;waterfall&lt;/strong&gt; 瀑布流的缩写，没发现有什么意义，忽略。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;重点是 &lt;strong&gt;max&lt;/strong&gt; 和 &lt;strong&gt;limit&lt;/strong&gt; 这两个值，经过测试发现，&lt;strong&gt;max&lt;/strong&gt; 是上一张图片的 &lt;strong&gt;pin_id&lt;/strong&gt;，服务器按先后顺序（采集顺序）返回这张图片&lt;strong&gt;后面&lt;/strong&gt;的 pin 数据；&lt;/p&gt;

&lt;p&gt;而 &lt;strong&gt;limit&lt;/strong&gt; 告诉服务器返回&lt;strong&gt;多少个&lt;/strong&gt; pin 数据。后面测出服务器对 &lt;strong&gt;limit&lt;/strong&gt; 做了最大值校验，最大是 &lt;strong&gt;100&lt;/strong&gt;，即一次最多只能加载100张图片数据。&lt;/p&gt;

&lt;p&gt;到了现在可以开始写爬虫模拟上面的操作了。&lt;/p&gt;

&lt;h2 id=&#34;node-爬虫实现&#34;&gt;Node 爬虫实现&lt;/h2&gt;

&lt;p&gt;使用 Node.js 实现命令行程序，提供两种方式下载图片：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;输入&lt;strong&gt;画板ID&lt;/strong&gt;下载该画板的所有图片&lt;/li&gt;
&lt;li&gt;输入&lt;strong&gt;用户ID&lt;/strong&gt;下载该用户所有自建画板的图片（不包括收藏的画板）&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;输入画板id下载该画板的所有图片&#34;&gt;输入画板ID下载该画板的所有图片&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在命令行中跟用户交互，使用 Node &lt;code&gt;readline&lt;/code&gt; API实现在 &lt;code&gt;stdin/stdout&lt;/code&gt; 读取输入和显示输出：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import readline from &#39;readline&#39;

const rl: readline.ReadLine = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
})
rl.question(&#39;画板ID：&#39;, boardId =&amp;gt; {})
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;首先根据画板ID获取 &lt;code&gt;board&lt;/code&gt; 数据，然后获取到 &lt;code&gt;board&lt;/code&gt; 中所有的 &lt;code&gt;pins&lt;/code&gt; 数据，最后根据每个 &lt;code&gt;pin&lt;/code&gt; 数据下载图片到本地目录中，中间向命令行中输出一些提示：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;async function downloadSingleBoard(boardId: string): Promise&amp;lt;void&amp;gt; {
  console.time(&#39;Total time&#39;)
  const board = await getBoardInfo(boardId)
  console.log(&#39;\n开始下载画板 %s - %s，图片数量：%d&#39;, boardId, board.title, board.pin_count)

  await getPinsAndDownload(board)
  outputResult()
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;根据画板ID获取 &lt;code&gt;board&lt;/code&gt; 数据。为了使用 ES7 的 &lt;code&gt;async/await&lt;/code&gt;，引入了 &lt;code&gt;promisify&lt;/code&gt; 的 request 库&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;import rp from &#39;request-promise&#39;

async function getBoardInfo(boardId: string): Promise&amp;lt;IBoard&amp;gt; {
  const response: {
    err?: number
    board: IBoard
  } = await rp({
    uri: `${huabanDomain}/boards/${boardId}/`,
    headers: jsonRequestHeader,
    qs: {
      limit: 1,
    },
    json: true,
  })
  if (response.err === 404) {
    throw new Error(&#39;画板不存在！&#39;)
  }

  return response.board
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;获取 &lt;code&gt;pins&lt;/code&gt; 数据然后下载图片，输出结果。其中在获取 &lt;code&gt;pins&lt;/code&gt; 数据的时候发现有些画板无法获取全部的 &lt;code&gt;pins&lt;/code&gt; 数据，造成画板图片下载不全（暂时还不清楚原因）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;async function getPinsAndDownload(board: IBoard): Promise&amp;lt;void&amp;gt; {
  const boardPins = await getPins(board.board_id)
  // TODO: 有些画板获取的pins数据不全？
  const missedPinsCount = board.pin_count - boardPins.length

  const boardPath = `${downloadPath}/${board.board_id} - ${board.title}`
  fs.emptyDirSync(boardPath)

  const downloadCount: number = await downloadImage(boardPins, boardPath)
  const failedCount: number = board.pin_count - downloadCount - missedPinsCount
  totalDownload += downloadCount

  console.log(
    `Done. 成功 %d 个${failedCount ? `，失败 \x1b[31m${failedCount}\x1b[0m个` : &#39;&#39;}${
      missedPinsCount ? `，丢失 \x1b[31m${missedPinsCount}\x1b[0m 个` : &#39;&#39;
    }`,
    downloadCount,
  )
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;获取画板中全部pins(图片)数据。有个关键的点，请求头部中如果不加上 &lt;code&gt;&#39;X-Requested-With&#39;: &#39;XMLHttpRequest&#39;&lt;/code&gt;，服务器返回的是包含json的HMLT Document，而不是单纯的 &lt;code&gt;json&lt;/code&gt; 数据。我看到有些脚本没有注意到这点，就需要用正则截取HTML中的 &lt;code&gt;json&lt;/code&gt;，多走了一步弯路（我也是从弯路走过来的，这里提醒后面的读者）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;// 关键头部，添加该项后服务器只会返回json数据，而不是包含json的HTML
const jsonRequestHeader = {
  Accept: &#39;application/json&#39;,
  &#39;X-Requested-With&#39;: &#39;XMLHttpRequest&#39;,
}

async function getPins(boardId: string): Promise&amp;lt;IPin[]&amp;gt; {
  const allPins: IPin[] = []

  async function loadPins(lastPinId: string = &#39;&#39;): Promise&amp;lt;void&amp;gt; {
    // limit 查询参数限制获取的pin数量，最大100，默认20
    const response = await rp({
      uri: `${huabanDomain}/boards/${boardId}/`,
      qs: {
        limit: 100,
        max: lastPinId,
      },
      headers: jsonRequestHeader,
      json: true,
    })

    const board = response.board
    // if (response.headers[&#39;content-type&#39;]!.includes(&#39;text/html&#39;)) {
    //   // 匹配 boards json 串
    //   const boardJson: string = /app\.page\[&amp;quot;board&amp;quot;\]\s=\s({.*});/.exec(response)![1]
    //   board = JSON.parse(boardJson)
    // }
    allPins.push(...board.pins)

    // 当此次获取的pins为空或者全部pins已获取完，则返回
    const pinsChunkLength: number = board.pins.length
    if (pinsChunkLength &amp;amp;&amp;amp; allPins.length &amp;lt; board.pin_count) {
      // 用最后一个pin id作为下一次请求的max值，表示获取该pin后面的pins
      await loadPins(board.pins[pinsChunkLength - 1].pin_id)
    }
  }

  await loadPins()
  return allPins
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;根据 &lt;code&gt;pins&lt;/code&gt; 下载图片。这里引入了 &lt;code&gt;async&lt;/code&gt; 异步库来控制同一时间的下载并发数，否则并发过高&lt;strong&gt;Node会失去响应&lt;/strong&gt;；下载失败的图片还会重试一次&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;async function downloadImage(allPins: IPin[], boardPath: string): Promise&amp;lt;number&amp;gt; {
  let downloadCount: number = 0
  const errorImageUrl: Array&amp;lt;{ url: string; path: string }&amp;gt; = []

  // 重试下载失败的图片
  function retry() {
    for (const image of errorImageUrl) {
      rp({
        uri: image.url,
        timeout: 20 * 1000,
        encoding: null, // make response a Buffer to write image correctly
      }).pipe(
        fs.createWriteStream(image.path).on(&#39;finish&#39;, () =&amp;gt; {
          totalDownload++
          console.log(&#39;\x1b[32m Retry ok! \x1b[0m %s&#39;, image.url)
        }),
      )
    }
  }

  function download(pin: IPin, cb: () =&amp;gt; void): void {
    const imageUrl: string = `${imageServer}/${pin.file.key}_fw658`
    const imageName: string = `${pin.pin_id}${imagesTypes[pin.file.type] || &#39;.jpg&#39;}`

    rp({
      uri: imageUrl,
      timeout: 20 * 1000,
      encoding: null, // make response a Buffer to write image correctly
    })
      .then(data =&amp;gt; {
        downloadCount++

        fs.writeFile(`${boardPath}/${imageName}`, data, error =&amp;gt; {
          error &amp;amp;&amp;amp; console.error(&#39;\x1b[31m%s\x1b[0m%s&#39;, error.message, imageUrl)
        })
      })
      .catch(error =&amp;gt; {
        console.error(&#39;\x1b[31m%s %s.\x1b[0m %s&#39;, &#39;Download image failed.&#39;, error.message, imageUrl)
        errorImageUrl.push({ url: imageUrl, path: `${boardPath}/${imageName}` })
      })
      .finally(cb)
  }

  // async控制并发下载数，否则并发数太高Node会失去响应
  return new Promise&amp;lt;number&amp;gt;(resolve =&amp;gt; {
    // 同一时间最多有10个(不能太高)并发请求
    async.eachLimit(allPins, 10, download, (error: IError | undefined) =&amp;gt; {
      if (error) {
        throw error
      }
      errorImageUrl.length &amp;amp;&amp;amp; retry()
      resolve(downloadCount)
    })
  })
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;下载的图片会保存在默认 &lt;code&gt;images&lt;/code&gt; 目录或者用户输入的指定目录中，下载速度平均 5 张/秒&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;输入用户id下载该用户所有自建画板的图片-不包括收藏的画板&#34;&gt;输入用户ID下载该用户所有自建画板的图片（不包括收藏的画板）&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;命令行中输入用户ID&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;rl.question(&#39;请输入地址栏中的用户名：&#39;, username =&amp;gt; {})
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;首先获取到该用户的所有画板数据，然后顺序下载每个画板中的图片&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;async function downloadBoardsOfUser(username: string): Promise&amp;lt;void&amp;gt; {
  console.time(&#39;Total time&#39;)
  const userBoards: IBoard[] = await getUserBoards(username)

  console.log(&#39;\n用户 [%s] 画板数量：%d&#39;, username, userBoards.length)

  // 顺序下载画板，并行下载会失控
  for (const board of userBoards) {
    console.log(
      &#39;\n开始下载画板：[%s - %s]，图片数量：%d&#39;,
      board.board_id,
      board.title,
      board.pin_count,
    )
    await getPinsAndDownload(board)
  }

  outputResult()
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;获取用户画板。用户画板也使用了懒加载方式，所以也需要去循环获取&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ts&#34;&gt;async function getUserBoards(username: string): Promise&amp;lt;IBoard[]&amp;gt; {
  const allUserBoards: IBoard[] = []

  async function getBoards(lastBoardId?: string): Promise&amp;lt;void&amp;gt; {
    const response: {
      err?: number
      user?: IUser
    } = await rp({
      uri: `${huabanDomain}/${username}/`,
      qs: {
        limit: 100,
        max: lastBoardId,
      },
      headers: jsonRequestHeader,
      json: true,
    })

    if (response.err === 404) {
      throw new Error(&#39;用户不存在！&#39;)
    } else if (!response.user!.board_count) {
      throw new Error(&#39;用户没有画板！&#39;)
    }

    const user: IUser = response.user!
    const requestUserBoardsCount = user.boards.length
    allUserBoards.push(...user.boards)

    // 获取所有画板数据
    if (requestUserBoardsCount &amp;amp;&amp;amp; allUserBoards.length &amp;lt; user.board_count) {
      await getBoards(user.boards[requestUserBoardsCount - 1].board_id)
    }
  }

  await getBoards()
  return allUserBoards
}
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;后面步骤跟方式一相同，这里只是使用 &lt;code&gt;for&lt;/code&gt; 循环下载多个画板图片&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;这次爬虫几乎没有遇到服务器的反抗，花瓣网没有做反爬虫检测，最基本的 &lt;code&gt;User-Agent&lt;/code&gt; 都不需要伪装，很适合爬虫初学者拿来练手；这种开放共享的精神值得表扬👍。&lt;/p&gt;

&lt;p&gt;遗留下了有些画板 &lt;code&gt;pins&lt;/code&gt; 数据不全的问题，等待有缘再解决。&lt;/p&gt;

&lt;h2 id=&#34;github-project&#34;&gt;Github Project&lt;/h2&gt;

&lt;p&gt;项目引入了 &lt;code&gt;TSLint&lt;/code&gt;、&lt;code&gt;Prettier&lt;/code&gt; 来规范代码风格，用 &lt;code&gt;ts-node&lt;/code&gt; 来执行 &lt;code&gt;.ts&lt;/code&gt; 程序；&lt;/p&gt;

&lt;p&gt;代码放到Github上了 ➡ &lt;a href=&#34;https://github.com/Jancat/huaban-crawl&#34;&gt;Jancat/huaban-crawl&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Enjoy the pictures ~&lt;/p&gt;</description>
      
    </item>
    
  </channel>
</rss>